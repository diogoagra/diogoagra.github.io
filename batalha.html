<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de An√°lise de Batalha</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        :root {
            --bg-color: #2c2f33;
            --card-bg-color: #23272a;
            --header-color: #ffffff;
            --text-color: #c8c8c8;
            --accent-color: #7289da;
            --friend-color: #43b581;
            --enemy-color: #f04747;
            --border-color: #40444b;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            transition: background-color 0.3s;
        }

        /* Main container for the whole page */
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background-color: var(--card-bg-color);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Grid container for sections with multiple cards */
        .card-grid {
            display: grid;
            grid-template-columns: 1fr; /* Mobile-first: single column */
            gap: 20px;
        }

        h1, h2 {
            color: var(--header-color);
            margin-top: 0;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        h2 {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
        }
        
        .chart-instructions {
            font-size: 0.9em;
            color: var(--text-color);
            text-align: center;
            margin-top: -10px;
            padding-bottom: 10px;
        }
        
        #timeline-chart-container {
            position: relative;
            height: 350px;
        }

        #data-input-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #log-input {
            width: 100%;
            min-height: 150px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }

        #analyze-btn {
            padding: 12px 20px;
            background-color: var(--accent-color);
            color: var(--header-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        #analyze-btn:hover {
            background-color: #5f73bc;
        }

        #dashboard-content {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
        }
        
        #dashboard-placeholder {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #888;
        }

        .stat-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            text-align: center;
        }

        .stat-card {
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
        }

        .stat-card .value {
            font-size: 2.2em;
            font-weight: bold;
            color: var(--accent-color);
            word-wrap: break-word;
            min-height: 40px;
        }
        .stat-card .label {
            font-size: 1em;
            color: var(--text-color);
            margin-top: 5px;
        }
        
        #battle-result-card {
            border-width: 2px;
            text-align: center;
            padding: 20px;
        }
        #battle-result-card .value {
            font-size: 2.5em;
        }

        .table-wrapper {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        /* Default wrapping for all cells */
        #full-log-table th, 
        #full-log-table td {
            white-space: normal;
            word-break: break-word;
        }

        /* No wrapping for specific columns in the full log table */
        #full-log-table th:nth-child(-n+4),
        #full-log-table td:nth-child(-n+4) {
            white-space: nowrap;
        }


        th {
            background-color: var(--bg-color);
            cursor: pointer;
        }
        
        tbody tr:hover {
            background-color: #2a2d31;
        }

        .friend { color: var(--friend-color); font-weight: bold; }
        .enemy { color: var(--enemy-color); font-weight: bold; }
        .level { font-style: italic; color: #f9a825; }
        
        .search-box {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--header-color);
            border-radius: 5px;
            box-sizing: border-box;
        }
        
        #battle-flow-container {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .flow-entry {
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            background-color: var(--bg-color);
            border-left: 5px solid;
        }
        
        .flow-entry.friend-death { border-left-color: var(--enemy-color); }
        .flow-entry.enemy-death { border-left-color: var(--friend-color); }
        
        .flow-entry .timestamp {
            font-size: 0.8em;
            color: #888;
            display: block;
            margin-bottom: 5px;
        }

        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--card-bg-color);
            padding: 20px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
        }

        .close-btn {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: white;
            text-decoration: none;
            cursor: pointer;
        }

        .delete-btn {
            cursor: pointer;
            color: var(--enemy-color);
            font-size: 1.2em;
            text-align: center;
            padding: 0 5px;
        }
        .delete-btn:hover {
            opacity: 0.7;
        }

        /* --- Media Queries for Responsiveness --- */

        /* Tablets and larger devices */
        @media (min-width: 768px) {
            .card-grid {
                /* Creates 2 columns on tablets */
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 1200px) {
            .card-grid.tri-column {
                 /* Creates 3 columns on large desktops */
                grid-template-columns: repeat(3, 1fr);
            }
            .stat-cards {
                /* On large screens, show 5 cards per row in the stats section */
                grid-template-columns: repeat(5, 1fr);
            }
        }

        /* Smaller mobile devices */
        @media (max-width: 600px) {
            .main-container {
                padding: 10px;
            }
            .card {
                padding: 15px;
            }
            h1 {
                font-size: 1.5em;
            }
            h2 {
                font-size: 1.25em;
            }
            .stat-card .value {
                font-size: 2em;
            }
            #analyze-btn {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>

    <div id="notificationModal" class="modal">
      <div class="modal-content">
        <span class="close-btn">&times;</span>
        <p id="modal-text"></p>
      </div>
    </div>

    <div class="main-container">
        <div class="card">
            <h1>üìä Dashboard de An√°lise de Batalha</h1>
            <div id="data-input-area">
                <textarea id="log-input" placeholder="Cole aqui os logs do seu bot do TS3..."></textarea>
                <button id="analyze-btn">Analisar Dados</button>
            </div>
        </div>

        <div id="dashboard-placeholder" class="card">
            <p>Aguardando dados para an√°lise...</p>
        </div>

        <!-- This container will be shown after analysis -->
        <div id="dashboard-content">
            <div class="card">
                <h2>Resultado da Batalha</h2>
                <div id="battle-result-card" class="stat-card">
                    <div class="value" id="battle-winner">-</div>
                    <div class="label" id="battle-winner-reason"></div>
                </div>
            </div>

            <div class="card">
                <h2>Vis√£o Geral</h2>
                <div class="stat-cards">
                    <div class="stat-card"><div class="value" id="total-deaths">0</div><div class="label">Total de Mortes</div></div>
                    <div class="stat-card"><div class="value" id="friend-deaths">0</div><div class="label">Amigos Mortos</div></div>
                    <div class="stat-card"><div class="value" id="enemy-deaths">0</div><div class="label">Inimigos Mortos</div></div>
                    <div class="stat-card"><div class="value" id="friend-kd">0.00</div><div class="label">K/D Amigos</div></div>
                    <div class="stat-card"><div class="value" id="enemy-kd">0.00</div><div class="label">K/D Inimigos</div></div>
                    <div class="stat-card"><div class="value" id="top-killer">-</div><div class="label">MVP da Batalha</div></div>
                    <div class="stat-card"><div class="value" id="most-deaths-player">-</div><div class="label">Mais Morreu</div></div>
                    <div class="stat-card"><div class="value" id="avg-level">0</div><div class="label">M√©dia de Level</div></div>
                    <div class="stat-card"><div class="value" id="first-victim">-</div><div class="label">Primeira V√≠tima</div></div>
                    <div class="stat-card"><div class="value" id="kill-streak">-</div><div class="label">Maior Sequ√™ncia</div></div>
                </div>
            </div>

            <div class="card">
                <h2>Linha do Tempo das Mortes</h2>
                <p class="chart-instructions">Use a roda do mouse para dar zoom. Clique e arraste para mover.</p>
                <div id="timeline-chart-container">
                    <canvas id="timelineChart"></canvas>
                </div>
            </div>

            <div class="card">
                 <h2>Fluxo da Batalha</h2>
                <div id="battle-flow-container"></div>
            </div>

            <div class="card-grid tri-column">
                <div class="card">
                    <h2>üèÜ Top 10 - Kills</h2>
                    <div class="table-wrapper">
                        <table id="top-killers-table">
                            <thead><tr><th>Jogador</th><th>Participa√ß√µes</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="card">
                    <h2>üíÄ Top 10 - Mortes</h2>
                    <div class="table-wrapper">
                        <table id="top-deaths-table">
                            <thead><tr><th>Jogador</th><th>Mortes</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="card">
                    <h2>üîù Maiores Levels Abatidos</h2>
                    <div class="table-wrapper">
                        <table id="top-level-deaths-table">
                            <thead><tr><th>Jogador</th><th>Level</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="card-grid">
                <div class="card">
                    <h2>Amigos Mortos (√önicos)</h2>
                    <div class="table-wrapper">
                        <table id="unique-friend-deaths-table">
                            <thead><tr><th>Jogador</th><th>Vezes que Morreu</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
                <div class="card">
                    <h2>Inimigos Mortos (√önicos)</h2>
                    <div class="table-wrapper">
                        <table id="unique-enemy-deaths-table">
                            <thead><tr><th>Jogador</th><th>Vezes que Morreu</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>O que √© K/D Ratio?</h2>
                <p>K/D Ratio (Kill/Death Ratio) √© uma m√©trica que mede a efici√™ncia em combate. Ela √© calculada dividindo o n√∫mero de abates (Kills) pelo n√∫mero de vezes que um time ou jogador morreu (Deaths). Um K/D acima de 1.0 significa que o time conseguiu mais abates do que sofreu mortes, indicando um bom desempenho.</p>
            </div>

            <div class="card">
                <h2>üìú Log de Eventos Completo</h2>
                <input type="text" id="searchInput" class="search-box" placeholder="Pesquisar por jogador, level ou data...">
                <div class="table-wrapper">
                    <table id="full-log-table">
                        <thead>
                            <tr>
                                <th>A√ß√£o</th>
                                <th data-sort="timestamp">Data</th>
                                <th data-sort="victim">V√≠tima</th>
                                <th data-sort="level">Level</th>
                                <th data-sort="killers">Respons√°veis pela Morte</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const analyzeBtn = document.getElementById('analyze-btn');
    const logInput = document.getElementById('log-input');
    const dashboardContent = document.getElementById('dashboard-content');
    const dashboardPlaceholder = document.getElementById('dashboard-placeholder');
    const searchInput = document.getElementById('searchInput');
    
    const modal = document.getElementById('notificationModal');
    const modalText = document.getElementById('modal-text');
    const closeBtn = document.querySelector('.close-btn');

    let charts = {};
    let playerTeamMap = {};
    let fullLogData = []; // Store the master list of events

    closeBtn.onclick = () => modal.style.display = "none";
    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    };

    function showModal(message) {
        modalText.textContent = message;
        modal.style.display = "flex";
    }

    analyzeBtn.addEventListener('click', () => {
        const rawLog = logInput.value;
        if (!rawLog.trim()) {
            showModal("Por favor, cole os dados dos logs na √°rea de texto.");
            return;
        }
        
        fullLogData = parseLogData(rawLog);
        if (fullLogData.length === 0) {
            showModal("Nenhuma morte de jogador (PvP) foi encontrada. Verifique o formato do texto.");
            return;
        }
        
        fullLogData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        recalculateDashboard();
    });
    
    searchInput.addEventListener('keyup', () => {
        const filter = searchInput.value.toUpperCase();
        const table = document.getElementById('full-log-table');
        const tr = table.getElementsByTagName('tr');

        for (let i = 1; i < tr.length; i++) {
            const row = tr[i];
            const textValue = row.textContent || row.innerText;
            if (textValue.toUpperCase().indexOf(filter) > -1) {
                row.style.display = "";
            } else {
                row.style.display = "none";
            }
        }
    });

    function recalculateDashboard() {
        if (fullLogData.length === 0) {
            dashboardPlaceholder.style.display = 'block';
            dashboardContent.style.display = 'none';
            showModal("Nenhuma morte de jogador (PvP) foi encontrada ap√≥s a filtragem.");
            return;
        }

        dashboardPlaceholder.style.display = 'none';
        dashboardContent.style.display = 'flex';
        
        Object.values(charts).forEach(chart => {
            if (chart) chart.destroy();
        });
        charts = {};
        
        try {
            buildPlayerTeamMap(fullLogData);
            updateDashboard(fullLogData);
        } catch (e) {
            console.error("Erro ao atualizar o dashboard:", e);
            showModal("Ocorreu um erro inesperado. Verifique o console do navegador para detalhes t√©cnicos.");
        }
    }

    function handleDeleteEvent(index) {
        fullLogData.splice(index, 1); // Remove the event from the master list
        recalculateDashboard(); // Recalculate and redraw everything
    }

    // --- START: ROBUST PARSING LOGIC ---
    function parseLogData(rawText) {
        // Pre-process the entire text to remove invisible characters (like zero-width spaces)
        // that can break the parsing, especially within timestamps.
        const cleanRawText = rawText.replace(/[\u200B-\u200D\uFEFF]/g, '');

        const lines = cleanRawText.split('\n');
        const deathEvents = [];
        let currentLogEntry = '';
        const processedDeaths = new Set(); // EVOLU√á√ÉO: Conjunto para rastrear mortes duplicadas.

        // Regex to remove the bot prefix from continuation lines.
        const prefixRegex = /^(Ôøº?<[^>]+>\s*["‚Äú][^"‚Äù]+["‚Äù]:\s*)?/;

        lines.forEach(line => {
            // Clean the prefix from the beginning of the line.
            const cleanedLine = line.replace(prefixRegex, '').trim();

            if (!cleanedLine) {
                return; // Skip empty lines
            }

            // Check if the cleaned line marks the beginning of a new death event.
            const isNewEntry = cleanedLine.startsWith('[AMIGO]') || cleanedLine.startsWith('[INIMIGO]') || cleanedLine.startsWith('[NEUTRO]');

            if (isNewEntry) {
                // If a log entry is already being built, process it first.
                if (currentLogEntry) {
                    processLine(currentLogEntry, deathEvents, processedDeaths);
                }
                // Start a new log entry.
                currentLogEntry = cleanedLine;
            } else if (currentLogEntry) {
                // This is a continuation of the previous line.
                // We concatenate directly without a space, as the bot's message splitting
                // doesn't add extra spaces. This correctly joins broken words and timestamps.
                currentLogEntry += cleanedLine;
            }
        });

        // Process the last remaining log entry after the loop finishes.
        if (currentLogEntry) {
            processLine(currentLogEntry, deathEvents, processedDeaths);
        }
        
        return deathEvents;
    }

    function processLine(fullLine, deathEvents, processedDeaths) {
        // The line is already mostly clean, just need to normalize spaces.
        let cleanedLine = fullLine.replace(/\s+/g, ' ').trim();

        // A regex agora ignora mortes que usam a palavra "Died", focando apenas em mortes PvP (Killed, Crushed, etc.).
        const pvpDeathMatch = cleanedLine.match(/^\[(AMIGO|INIMIGO|NEUTRO)\] - ([\d\- :]+) \+0000 UTC - (.+?) - (?:Killed|Crushed|Slain|Annihilated|Eliminated) at Level (\d+) by (.*?)(?:\.Assisted by (.*))?\.?$/);
        
        if (pvpDeathMatch) {
            const [, teamTag, timestampRaw, victim, level, killersRaw, assistsRaw] = pvpDeathMatch;
            
            const timestamp = timestampRaw.trim().replace(' ', 'T');
            const victimName = victim.trim();

            // EVOLU√á√ÉO: L√≥gica para ignorar duplicatas.
            // Cria um identificador √∫nico para cada morte (timestamp + nome da v√≠tima).
            const deathIdentifier = `${timestamp}-${victimName}`;
            if (processedDeaths.has(deathIdentifier)) {
                return; // √â uma duplicata, ent√£o ignoramos.
            }
            processedDeaths.add(deathIdentifier); // Adiciona ao conjunto para prevenir futuras duplicatas.

            const killers = killersRaw.split(/, | and /).map(k => k.trim());
            
            let team = '';
            if (teamTag === 'AMIGO') team = 'Amigos';
            else if (teamTag === 'INIMIGO') team = 'Inimigos';
            else team = 'Neutros';

            deathEvents.push({ team, timestamp, victim: victimName, level: parseInt(level), killers, assists: [] });
            return;
        }
        
        // Qualquer outra linha, incluindo as com "Died at Level", ser√° ignorada pois n√£o corresponde √† regex acima.
    }
    // --- END: ROBUST PARSING LOGIC ---

    function buildPlayerTeamMap(data) {
        playerTeamMap = {};
        data.forEach(event => {
            if (!playerTeamMap[event.victim]) {
                playerTeamMap[event.victim] = event.team;
            }
        });
    }

    function getPlayerClass(playerName) {
        if (playerTeamMap[playerName]) {
            const team = playerTeamMap[playerName];
            if (team === 'Amigos') return 'friend';
            if (team === 'Inimigos') return 'enemy';
        }
        // Fallback for players who only get kills and never die.
        if (playerName.toLowerCase().includes('retro manda')) {
            return 'friend';
        }
        return ''; // Neutral
    }

    function updateDashboard(data) {
        updateGeneralStats(data);
        updateTimelineChart(data);
        updateBattleFlow(data);
        updateRankings(data);
        updateUniqueDeathsTables(data);
        populateFullLogTable(data);
    }

    function updateGeneralStats(data) {
        // Data is already pre-sorted, so no need to re-sort here.
        // Sorting is crucial for 'First Victim' and 'Kill Streak'.
        document.getElementById('total-deaths').textContent = data.length;
        
        const avgLevel = data.length > 0 ? (data.reduce((sum, entry) => sum + entry.level, 0) / data.length).toFixed(0) : 0;
        document.getElementById('avg-level').textContent = avgLevel;

        const deathCounts = data.reduce((acc, entry) => {
            acc[entry.victim] = (acc[entry.victim] || 0) + 1;
            return acc;
        }, {});
        const mostDeathsPlayer = Object.keys(deathCounts).length > 0 ? Object.keys(deathCounts).reduce((a, b) => deathCounts[a] > deathCounts[b] ? a : b) : '-';
        document.getElementById('most-deaths-player').textContent = mostDeathsPlayer;

        let friendDeaths = 0;
        let enemyDeaths = 0;
        let friendKills = 0;
        let enemyKills = 0;
        
        data.forEach(event => {
            const isMonsterKill = event.killers.includes('Monstro/Ambiente');
            
            if (event.team === 'Amigos') { // A friend died
                friendDeaths++;
                if (!isMonsterKill) {
                    enemyKills++;
                }
            } else if (event.team === 'Inimigos') { // An enemy died
                enemyDeaths++;
                if (!isMonsterKill) {
                    friendKills++;
                }
            }
        });

        document.getElementById('friend-deaths').textContent = friendDeaths;
        document.getElementById('enemy-deaths').textContent = enemyDeaths;
        
        const friendKD = friendDeaths > 0 ? (friendKills / friendDeaths).toFixed(2) : friendKills.toFixed(2);
        const enemyKD = enemyDeaths > 0 ? (enemyKills / enemyDeaths).toFixed(2) : enemyKills.toFixed(2);
        document.getElementById('friend-kd').textContent = friendKD;
        document.getElementById('enemy-kd').textContent = enemyKD;

        const killerCounts = {};
        data.forEach(event => {
            event.killers.forEach(killer => {
                if(killer.includes(' of ') || killer === 'Monstro/Ambiente') return;
                killerCounts[killer] = (killerCounts[killer] || 0) + 1;
            });
        });
        const topKiller = Object.keys(killerCounts).length > 0 ? Object.keys(killerCounts).reduce((a, b) => killerCounts[a] > killerCounts[b] ? a : b) : '-';
        document.getElementById('top-killer').textContent = topKiller;

        // Battle Result
        const winnerEl = document.getElementById('battle-winner');
        const reasonEl = document.getElementById('battle-winner-reason');
        const resultCard = document.getElementById('battle-result-card');
        
        if (friendDeaths === 0 && enemyDeaths > 0) {
            winnerEl.textContent = "Amigos Venceram";
            winnerEl.className = "value friend";
            resultCard.style.borderColor = "var(--friend-color)";
            reasonEl.textContent = `K/D Perfeito com ${friendKills} abates e 0 mortes.`;
        } else if (enemyDeaths === 0 && friendDeaths > 0) {
            winnerEl.textContent = "Inimigos Venceram";
            winnerEl.className = "value enemy";
            resultCard.style.borderColor = "var(--enemy-color)";
            reasonEl.textContent = `K/D Perfeito com ${enemyKills} abates e 0 mortes.`;
        } else if (friendDeaths === 0 && enemyDeaths === 0) {
            if (data.length > 0) { // Check if there were any kills at all
                 winnerEl.textContent = "Empate";
                winnerEl.className = "value";
                resultCard.style.borderColor = "var(--border-color)";
                reasonEl.textContent = `Batalha sem mortes de jogadores.`;
            } else {
                 winnerEl.textContent = "-";
                winnerEl.className = "value";
                resultCard.style.borderColor = "var(--border-color)";
                reasonEl.textContent = `Aguardando dados...`;
            }
        } else { 
            if (parseFloat(friendKD) > parseFloat(enemyKD)) {
                winnerEl.textContent = "Amigos Venceram";
                winnerEl.className = "value friend";
                resultCard.style.borderColor = "var(--friend-color)";
                reasonEl.textContent = `Com um K/D Ratio de ${friendKD} contra ${enemyKD}`;
            } else if (parseFloat(enemyKD) > parseFloat(friendKD)) {
                winnerEl.textContent = "Inimigos Venceram";
                winnerEl.className = "value enemy";
                resultCard.style.borderColor = "var(--enemy-color)";
                reasonEl.textContent = `Com um K/D Ratio de ${enemyKD} contra ${friendKD}`;
            } else {
                winnerEl.textContent = "Empate";
                winnerEl.className = "value";
                resultCard.style.borderColor = "var(--border-color)";
                reasonEl.textContent = `Ambos os times tiveram um K/D Ratio de ${friendKD}`;
            }
        }


        // First Victim
        const firstDeath = data[0]; // Uses 'data' which is now sorted
        if (firstDeath) {
            const firstVictim = firstDeath.victim;
            const firstVictimClass = getPlayerClass(firstVictim);
            document.getElementById('first-victim').innerHTML = `<span class="${firstVictimClass}">${firstVictim}</span>`;
        } else {
            document.getElementById('first-victim').textContent = '-';
        }
        

        // Kill Streak
        let currentStreak = 0;
        let maxStreak = 0;
        let currentStreakTeam = null;
        let maxStreakTeam = null;

        data.forEach(event => { // Uses 'data' which is now sorted
            if (event.killers.includes('Monstro/Ambiente')) {
                currentStreak = 0;
                currentStreakTeam = null;
                return;
            }
            
            const killTeam = event.team === 'Amigos' ? 'Inimigos' : 'Amigos';

            if (killTeam === currentStreakTeam) {
                currentStreak++;
            } else {
                currentStreak = 1;
                currentStreakTeam = killTeam;
            }

            if (currentStreak > maxStreak) {
                maxStreak = currentStreak;
                maxStreakTeam = currentStreakTeam;
            }
        });
        const streakEl = document.getElementById('kill-streak');
        if (maxStreakTeam) {
            streakEl.innerHTML = `Sequ√™ncia de ${maxStreak} para os <span class="${maxStreakTeam === 'Amigos' ? 'friend' : 'enemy'}">${maxStreakTeam}</span>`;
        } else {
            streakEl.textContent = '-';
        }
    }
    
    function updateRankings(data) {
        const killerCounts = {};
        data.forEach(event => {
            event.killers.forEach(killer => {
                if(killer.includes(' of ') || killer === 'Monstro/Ambiente') return;
                killerCounts[killer] = (killerCounts[killer] || 0) + 1;
            });
        });
        const sortedKills = Object.entries(killerCounts).sort(([, a], [, b]) => b - a).slice(0, 10);
        populateTable('top-killers-table', sortedKills);

        const deathCounts = {};
        data.forEach(event => {
            if (!deathCounts[event.victim]) {
                deathCounts[event.victim] = { count: 0, team: event.team };
            }
            deathCounts[event.victim].count++;
        });
        const sortedDeaths = Object.entries(deathCounts).sort(([, a], [, b]) => b.count - a.count).slice(0, 10);
        populateDeathsTable('top-deaths-table', sortedDeaths);
        
        const sortedLevelDeaths = [...data].sort((a, b) => b.level - a.level).slice(0, 10);
        const topLevelDeathsBody = document.querySelector('#top-level-deaths-table tbody');
        topLevelDeathsBody.innerHTML = '';
        sortedLevelDeaths.forEach(death => {
            const row = topLevelDeathsBody.insertRow();
            let teamClass = '';
            if (death.team === 'Amigos') teamClass = 'friend';
            else if (death.team === 'Inimigos') teamClass = 'enemy';
            row.innerHTML = `<td class="${teamClass}">${death.victim}</td><td>${death.level}</td>`;
        });
    }

    function updateUniqueDeathsTables(data) {
        const friendDeaths = {};
        const enemyDeaths = {};

        data.forEach(event => {
            if (event.team === 'Amigos') {
                friendDeaths[event.victim] = (friendDeaths[event.victim] || 0) + 1;
            } else if (event.team === 'Inimigos') {
                enemyDeaths[event.victim] = (enemyDeaths[event.victim] || 0) + 1;
            }
        });

        const sortedFriendDeaths = Object.entries(friendDeaths).sort(([, a], [, b]) => b - a);
        const sortedEnemyDeaths = Object.entries(enemyDeaths).sort(([, a], [, b]) => b - a);

        populateSimpleDeathsTable('unique-friend-deaths-table', sortedFriendDeaths, 'friend');
        populateSimpleDeathsTable('unique-enemy-deaths-table', sortedEnemyDeaths, 'enemy');
    }
    
    function populateTable(tableId, data) {
        const tableBody = document.querySelector(`#${tableId} tbody`);
        tableBody.innerHTML = '';
        data.forEach(([name, count]) => {
            const row = tableBody.insertRow();
            const teamClass = getPlayerClass(name);
            row.innerHTML = `<td class="${teamClass}">${name}</td><td>${count}</td>`;
        });
    }

    function populateDeathsTable(tableId, data) {
        const tableBody = document.querySelector(`#${tableId} tbody`);
        tableBody.innerHTML = '';
        data.forEach(([name, details]) => {
            const row = tableBody.insertRow();
            let teamClass = '';
            if (details.team === 'Amigos') teamClass = 'friend';
            else if (details.team === 'Inimigos') teamClass = 'enemy';
            row.innerHTML = `<td class="${teamClass}">${name}</td><td>${details.count}</td>`;
        });
    }

    function populateSimpleDeathsTable(tableId, data, teamClass) {
        const tableBody = document.querySelector(`#${tableId} tbody`);
        tableBody.innerHTML = '';
        data.forEach(([name, count]) => {
            const row = tableBody.insertRow();
            row.innerHTML = `<td class="${teamClass}">${name}</td><td>${count}</td>`;
        });
    }

    function populateFullLogTable(data) {
        const tableBody = document.querySelector('#full-log-table tbody');
        tableBody.innerHTML = '';
        data.forEach((event, index) => {
            const row = tableBody.insertRow();
            const victimClass = event.team === 'Amigos' ? 'friend' : 'enemy';
            const killersHtml = event.killers.map(k => {
                const killerClass = getPlayerClass(k);
                return `<span class="${killerClass}">${k}</span>`;
            }).join(', ');
            
            // Formats the ISO date to a readable format (dd/MM/yyyy HH:mm:ss)
            const displayDate = new Date(event.timestamp).toLocaleString('pt-BR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hour12: false
            }).replace(',', '');

            row.innerHTML = `
                <td><span class="delete-btn" data-index="${index}">üóëÔ∏è</span></td>
                <td>${displayDate}</td>
                <td class="${victimClass}">${event.victim}</td>
                <td class="level">${event.level}</td>
                <td>${killersHtml}</td>
            `;
        });
        // Add event listeners to the new delete buttons
        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const indexToDelete = parseInt(e.target.getAttribute('data-index'));
                handleDeleteEvent(indexToDelete);
            });
        });
    }

    function updateBattleFlow(data) {
        const container = document.getElementById('battle-flow-container');
        container.innerHTML = '';

        // Data is already pre-sorted.
        data.forEach(event => {
            const entry = document.createElement('div');
            
            let victimClass = '';
            if (event.team === 'Amigos') victimClass = 'friend';
            else if (event.team === 'Inimigos') victimClass = 'enemy';
            
            let entryClass = '';
            if (event.team === 'Amigos') entryClass = 'friend-death';
            else if (event.team === 'Inimigos') entryClass = 'enemy-death';
            
            entry.className = `flow-entry ${entryClass}`;


            const killersHtml = event.killers.map(k => {
                const killerClass = getPlayerClass(k);
                return `<span class="${killerClass}">${k}</span>`;
            }).join(', ');

            const time = new Date(event.timestamp).toLocaleTimeString('pt-BR');

            entry.innerHTML = `
                <span class="timestamp">${time}</span>
                <div>
                    <strong class="${victimClass}">${event.victim}</strong>
                    <span class="level"> (Lvl ${event.level})</span>
                    foi morto por 
                    <strong>${killersHtml}</strong>
                </div>
            `;
            container.appendChild(entry);
        });
    }

    function updateTimelineChart(data) {
        if (charts.timeline) {
            charts.timeline.destroy();
        }

        const friendDeathsData = data.filter(d => d.team === 'Amigos').map(d => ({ x: d.timestamp, y: d.level, player: d.victim }));
        const enemyDeathsData = data.filter(d => d.team === 'Inimigos').map(d => ({ x: d.timestamp, y: d.level, player: d.victim }));

        const ctx = document.getElementById('timelineChart').getContext('2d');
        charts.timeline = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Amigo Morto',
                    data: friendDeathsData,
                    backgroundColor: 'rgba(67, 181, 129, 0.7)',
                    borderColor: 'rgba(67, 181, 129, 1)',
                    borderWidth: 1,
                    pointRadius: 6,
                    pointHoverRadius: 8
                }, {
                    label: 'Inimigo Morto',
                    data: enemyDeathsData,
                    backgroundColor: 'rgba(240, 71, 71, 0.7)',
                    borderColor: 'rgba(240, 71, 71, 1)',
                    borderWidth: 1,
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute', // Adjusted for better visualization
                            tooltipFormat: 'dd/MM/yyyy HH:mm:ss'
                        },
                        title: { display: true, text: 'Data', color: 'white' },
                        ticks: { color: 'white' }
                    },
                    y: {
                       display: true,
                       beginAtZero: false,
                       title: { display: true, text: 'Level da V√≠tima', color: 'white' },
                       ticks: { color: 'white' }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: 'white'
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const point = context.raw;
                                return `${point.player} (Level ${point.y})`;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                        }
                    }
                }
            }
        });
    }

});
</script>

</body>
</html>
